{"ast":null,"code":"import behaviors from './behaviors';\n\nclass CETEI {\n  constructor(base) {\n    this.els = [];\n    this.namespaces = new Map();\n    this.behaviors = {};\n    this.hasStyle = false;\n    this.prefixDefs = [];\n\n    if (base) {\n      this.base = base;\n    } else {\n      try {\n        if (window) {\n          this.base = window.location.href.replace(/\\/[^\\/]*$/, \"/\");\n        }\n      } catch (e) {\n        this.base = \"\";\n      }\n    }\n\n    this.addBehaviors(behaviors);\n    this.shadowCSS;\n    this.supportsShadowDom = document.head.createShadowRoot || document.head.attachShadow;\n  } // public method\n\n  /* Returns a Promise that fetches an XML source document from the URL\n     provided in the first parameter and then calls the makeHTML5 method\n     on the returned document.\n   */\n\n\n  getHTML5(XML_url, callback, perElementFn) {\n    if (window.location.href.startsWith(this.base) && XML_url.indexOf(\"/\") >= 0) {\n      this.base = XML_url.replace(/\\/[^\\/]*$/, \"/\");\n    } // Get XML from XML_url and create a promise\n\n\n    let promise = new Promise(function (resolve, reject) {\n      let client = new XMLHttpRequest();\n      client.open('GET', XML_url);\n      client.send();\n\n      client.onload = function () {\n        if (this.status >= 200 && this.status < 300) {\n          resolve(this.response);\n        } else {\n          reject(this.statusText);\n        }\n      };\n\n      client.onerror = function () {\n        reject(this.statusText);\n      };\n    }).catch(function (reason) {\n      // TODO: better error handling?\n      console.log(reason);\n    });\n    return promise.then(XML => {\n      return this.makeHTML5(XML, callback, perElementFn);\n    });\n  }\n  /* Converts the supplied XML string into HTML5 Custom Elements. If a callback\n     function is supplied, calls it on the result.\n   */\n\n\n  makeHTML5(XML, callback, perElementFn) {\n    // XML is assumed to be a string\n    let XML_dom = new DOMParser().parseFromString(XML, \"text/xml\");\n    return this.domToHTML5(XML_dom, callback, perElementFn);\n  }\n  /* Converts the supplied XML DOM into HTML5 Custom Elements. If a callback\n     function is supplied, calls it on the result.\n  */\n\n\n  domToHTML5(XML_dom, callback, perElementFn) {\n    this._learnElementNames(XML_dom);\n\n    let convertEl = el => {\n      // Elements with defined namespaces get the prefix mapped to that element. All others keep\n      // their namespaces and are copied as-is.\n      let newElement;\n\n      if (this.namespaces.has(el.namespaceURI ? el.namespaceURI : \"\")) {\n        let prefix = this.namespaces.get(el.namespaceURI ? el.namespaceURI : \"\");\n        newElement = document.createElement(prefix + \"-\" + el.localName);\n      } else {\n        newElement = document.importNode(el, false);\n      } // Copy attributes; @xmlns, @xml:id, @xml:lang, and\n      // @rendition get special handling.\n\n\n      for (let att of Array.from(el.attributes)) {\n        if (att.name == \"xmlns\") {\n          newElement.setAttribute(\"data-xmlns\", att.value); //Strip default namespaces, but hang on to the values\n        } else {\n          newElement.setAttribute(att.name, att.value);\n        }\n\n        if (att.name == \"xml:id\") {\n          newElement.setAttribute(\"id\", att.value);\n        }\n\n        if (att.name == \"xml:lang\") {\n          newElement.setAttribute(\"lang\", att.value);\n        }\n\n        if (att.name == \"rendition\") {\n          newElement.setAttribute(\"class\", att.value.replace(/#/g, \"\"));\n        }\n      } // Preserve element name so we can use it later\n\n\n      newElement.setAttribute(\"data-origname\", el.localName); // If element is empty, flag it\n\n      if (el.childNodes.length == 0) {\n        newElement.setAttribute(\"data-empty\", \"\");\n      } // Turn <rendition scheme=\"css\"> elements into HTML styles\n\n\n      if (el.localName == \"tagsDecl\") {\n        let style = document.createElement(\"style\");\n\n        for (let node of Array.from(el.childNodes)) {\n          if (node.nodeType == Node.ELEMENT_NODE && node.localName == \"rendition\" && node.getAttribute(\"scheme\") == \"css\") {\n            let rule = \"\";\n\n            if (node.hasAttribute(\"selector\")) {\n              //rewrite element names in selectors\n              rule += node.getAttribute(\"selector\").replace(/([^#, >]+\\w*)/g, \"tei-$1\").replace(/#tei-/g, \"#\") + \"{\\n\";\n              rule += node.textContent;\n            } else {\n              rule += \".\" + node.getAttribute(\"xml:id\") + \"{\\n\";\n              rule += node.textContent;\n            }\n\n            rule += \"\\n}\\n\";\n            style.appendChild(document.createTextNode(rule));\n          }\n        }\n\n        if (style.childNodes.length > 0) {\n          newElement.appendChild(style);\n          this.hasStyle = true;\n        }\n      } // Get prefix definitions\n\n\n      if (el.localName == \"prefixDef\") {\n        this.prefixDefs.push(el.getAttribute(\"ident\"));\n        this.prefixDefs[el.getAttribute(\"ident\")] = {\n          \"matchPattern\": el.getAttribute(\"matchPattern\"),\n          \"replacementPattern\": el.getAttribute(\"replacementPattern\")\n        };\n      }\n\n      for (let node of Array.from(el.childNodes)) {\n        if (node.nodeType == Node.ELEMENT_NODE) {\n          newElement.appendChild(convertEl(node));\n        } else {\n          newElement.appendChild(node.cloneNode());\n        }\n      }\n\n      if (perElementFn) {\n        perElementFn(newElement, el);\n      }\n\n      return newElement;\n    };\n\n    this.dom = convertEl(XML_dom.documentElement);\n    this.applyBehaviors();\n    this.done = true;\n\n    if (callback) {\n      callback(this.dom, this);\n      window.dispatchEvent(ceteiceanLoad);\n    } else {\n      window.dispatchEvent(ceteiceanLoad);\n      return this.dom;\n    }\n  }\n  /*  Define or apply behaviors for the document\n   *\n   */\n\n\n  applyBehaviors() {\n    if (window.customElements) {\n      this.define(this.els);\n    } else {\n      this.fallback(this.els);\n    }\n  }\n  /* If the TEI document defines CSS styles in its tagsDecl, this method\n     copies them into the wrapper HTML document's head.\n   */\n\n\n  addStyle(doc, data) {\n    if (this.hasStyle) {\n      doc.getElementsByTagName(\"head\").item(0).appendChild(data.getElementsByTagName(\"style\").item(0).cloneNode(true));\n    }\n  }\n  /* If a URL where CSS for styling Shadow DOM elements lives has been defined,\n     insert it into the Shadow DOM. DEPRECATED\n   */\n\n\n  addShadowStyle(shadow) {\n    if (this.shadowCSS) {\n      shadow.innerHTML = \"<style>\" + \"@import url(\\\"\" + this.shadowCSS + \"\\\");</style>\" + shadow.innerHTML;\n    }\n  }\n  /* Add a user-defined set of behaviors to CETEIcean's processing\n     workflow. Added behaviors will override predefined behaviors with the\n     same name.\n  */\n\n\n  addBehaviors(bhvs) {\n    if (bhvs.namespaces) {\n      for (let prefix of Object.keys(bhvs.namespaces)) {\n        if (!this.namespaces.has(bhvs.namespaces[prefix]) && !Array.from(this.namespaces.values()).includes(prefix)) {\n          this.namespaces.set(bhvs.namespaces[prefix], prefix);\n        }\n      }\n    }\n\n    for (let prefix of this.namespaces.values()) {\n      if (bhvs[prefix]) {\n        for (let b of Object.keys(bhvs[prefix])) {\n          this.behaviors[prefix + \":\" + b] = bhvs[prefix][b];\n        }\n      }\n    } // Support old-style TEI-specific behaviors\n\n\n    if (bhvs.handlers) {\n      for (let b of Object.keys(bhvs.handlers)) {\n        if (b !== \"egXML\") {\n          this.behaviors[\"tei:\" + b] = bhvs.handlers[b];\n        } else {\n          this.behaviors[\"teieg:egXML\"] = bhvs.handlers[b];\n        }\n      }\n    }\n\n    if (bhvs[\"fallbacks\"]) {\n      console.log(\"Fallback behaviors are no longer used.\");\n    }\n  }\n  /* Adds or replaces an individual behavior. Takes a namespace prefix or namespace definition,\n   * the element name, and the behavior. E.g.\n   * addBehavior(\"tei\", \"add\", [\"`\",\"`\"]) for an already-declared namespace or\n   * addBehavior({\"doc\": \"http://docbook.org/ns/docbook\"}, \"note\", [\"[\",\"]\"]) for a new one\n   */\n\n\n  addBehavior(ns, element, b) {\n    let p;\n\n    if (ns === Object(ns)) {\n      for (let prefix of Object.keys(ns)) {\n        if (!this.namespaces.has(ns[prefix])) {\n          this.namespaces.set(ns[prefix], prefix);\n          p = prefix;\n        }\n      }\n    } else {\n      p = ns;\n    }\n\n    this.behaviors[p + \":\" + element] = b;\n  }\n  /* To change a namespace -> prefix mapping, the namespace must first be \n     unset. Takes a namespace URI. In order to process a TEI P4 document, e.g.,\n     the TEI namespace must be unset before it can be set to the empty string.\n  */\n\n\n  unsetNamespace(ns) {\n    this.namespaces.delete(ns);\n  }\n  /* Sets the base URL for the document. Used to rewrite relative links in the\n     XML source (which may be in a completely different location from the HTML\n     wrapper).\n   */\n\n\n  setBaseUrl(base) {\n    this.base = base;\n  } // \"private\" method\n\n\n  _learnElementNames(XML_dom) {\n    let root = XML_dom.documentElement;\n    this.els = new Set(Array.from(root.querySelectorAll(\"*\"), e => (this.namespaces.has(e.namespaceURI ? e.namespaceURI : \"\") ? this.namespaces.get(e.namespaceURI ? e.namespaceURI : \"\") + \":\" : \"\") + e.localName));\n    this.els.add((this.namespaces.has(root.namespaceURI ? root.namespaceURI : \"\") ? this.namespaces.get(root.namespaceURI ? root.namespaceURI : \"\") + \":\" : \"\") + root.localName); // Add the root element to the array\n  } // private method\n\n\n  _insert(elt, strings) {\n    let span = document.createElement(\"span\");\n\n    for (let node of Array.from(elt.childNodes)) {\n      if (node.nodeType === Node.ELEMENT_NODE && !node.hasAttribute(\"data-processed\")) {\n        this._processElement(node);\n      }\n    } // If we have before and after tags have them parsed by\n    // .innerHTML and then add the content to the resulting child\n\n\n    if (strings[0].match(\"<[^>]+>\") && strings[1] && strings[1].match(\"<[^>]+>\")) {\n      span.innerHTML = strings[0] + (strings[1] ? strings[1] : \"\");\n\n      for (let node of Array.from(elt.childNodes)) {\n        span.firstElementChild.appendChild(node.cloneNode(true));\n      }\n    } else {\n      span.innerHTML = strings[0];\n      span.setAttribute(\"data-before\", strings[0].replace(/<[^>]+>/g, \"\").length);\n\n      for (let node of Array.from(elt.childNodes)) {\n        span.appendChild(node.cloneNode(true));\n      }\n\n      if (strings.length > 1) {\n        span.innerHTML += strings[1];\n        span.setAttribute(\"data-after\", strings[1].replace(/<[^>]+>/g, \"\").length);\n      }\n    }\n\n    return span;\n  } // private method. Runs behaviors recursively on the supplied element and children\n\n\n  _processElement(elt) {\n    if (elt.hasAttribute(\"data-origname\") && !elt.hasAttribute(\"data-processed\")) {\n      let fn = this.getFallback(this._bName(elt));\n\n      if (fn) {\n        this.append(fn, elt);\n        elt.setAttribute(\"data-processed\", \"\");\n      }\n    }\n\n    for (let node of Array.from(elt.childNodes)) {\n      if (node.nodeType === Node.ELEMENT_NODE) {\n        this._processElement(node);\n      }\n    }\n  } // private method\n\n\n  _template(str, elt) {\n    let result = str;\n\n    if (str.search(/\\$(\\w*)(@([a-zA-Z:]+))/)) {\n      let re = /\\$(\\w*)@([a-zA-Z:]+)/g;\n      let replacements;\n\n      while (replacements = re.exec(str)) {\n        if (elt.hasAttribute(replacements[2])) {\n          if (replacements[1] && this[replacements[1]]) {\n            result = result.replace(replacements[0], this[replacements[1]].call(this, elt.getAttribute(replacements[2])));\n          } else {\n            result = result.replace(replacements[0], elt.getAttribute(replacements[2]));\n          }\n        }\n      }\n    }\n\n    return result;\n  } // Private method. Given a qualified name (e.g. tei:text), return the element name\n\n\n  _tagName(name) {\n    if (name.includes(\":\"), 1) {\n      return name.replace(/:/, \"-\").toLowerCase();\n      ;\n    } else {\n      return \"ceteicean-\" + name.toLowerCase();\n    }\n  } // Private method. Given an element, return its qualified name as defined in a behaviors object\n\n\n  _bName(e) {\n    return e.tagName.substring(0, e.tagName.indexOf(\"-\")).toLowerCase() + \":\" + e.getAttribute(\"data-origname\");\n  }\n  /* Takes a template in the form of either an array of 1 or 2 \n     strings or an object with CSS selector keys and either functions\n     or arrays as described above. Returns a closure around a function \n     that can be called in the element constructor or applied to an \n     individual element.\n      Called by the getHandler() and getFallback() methods\n  */\n\n\n  decorator(template) {\n    if (Array.isArray(template) && !Array.isArray(template[0])) {\n      return this._decorator(template);\n    }\n\n    let ceteicean = this;\n    return function (elt) {\n      for (let rule of template) {\n        if (elt.matches(rule[0]) || rule[0] === \"_\") {\n          if (Array.isArray(rule[1])) {\n            return ceteicean._decorator(rule[1]).call(ceteicean, elt);\n          } else {\n            return rule[1].call(ceteicean, elt);\n          }\n        }\n      }\n    };\n  }\n\n  _decorator(strings) {\n    let ceteicean = this;\n    return function (elt) {\n      let copy = [];\n\n      for (let i = 0; i < strings.length; i++) {\n        copy.push(ceteicean._template(strings[i], elt));\n      }\n\n      return ceteicean._insert(elt, copy);\n    };\n  }\n  /* Returns the handler function for the given element name\n      Called by define().\n   */\n\n\n  getHandler(fn) {\n    if (this.behaviors[fn]) {\n      if ({}.toString.call(this.behaviors[fn]) === '[object Function]') {\n        return this.append(this.behaviors[fn]);\n      } else {\n        return this.append(this.decorator(this.behaviors[fn]));\n      }\n    }\n  }\n  /* Returns the fallback function for the given element name.\n     Called by fallback().\n   */\n\n\n  getFallback(fn) {\n    if (this.behaviors[fn]) {\n      if ({}.toString.call(this.behaviors[fn]) === '[object Function]') {\n        return this.behaviors[fn];\n      } else {\n        return this.decorator(this.behaviors[fn]);\n      }\n    }\n  }\n  /* Appends any element returned by the function passed in the first\n   * parameter to the element in the second parameter. If the function\n   * returns nothing, this is a no-op aside from any side effects caused\n   * by the provided function.\n    * called by getHandler() and fallback()\n   */\n\n\n  append(fn, elt) {\n    if (elt) {\n      let content = fn.call(this, elt);\n\n      if (content && !this._childExists(elt.firstElementChild, content.nodeName)) {\n        this._appendBasic(elt, content);\n      }\n    } else {\n      let self = this;\n      return function () {\n        if (!this.hasAttribute(\"data-processed\")) {\n          let content = fn.call(self, this);\n\n          if (content && !self._childExists(this.firstElementChild, content.nodeName)) {\n            self._appendBasic(this, content);\n          }\n        }\n      };\n    }\n  }\n\n  attach(elt, fn, node) {\n    elt[fn].call(elt, node);\n\n    if (node.nodeType === Node.ELEMENT_NODE) {\n      for (let e of Array.from(node.childNodes)) {\n        this._processElement(e);\n      }\n    }\n  }\n  /* Private method called by append(). Takes a child element and a name, and recurses through the\n   * child's siblings until an element with that name is found, returning true if it is and false if not.\n   */\n\n\n  _childExists(elt, name) {\n    if (elt && elt.nodeName == name) {\n      return true;\n    } else {\n      return elt && elt.nextElementSibling && this._childExists(elt.nextElementSibling, name);\n    }\n  }\n  /* DEPRECATED. Private method called by append() if the browser supports Shadow DOM. \n   */\n\n\n  _appendShadow(elt, content) {\n    var shadow = elt.attachShadow({\n      mode: 'open'\n    });\n    this.addShadowStyle(shadow);\n    shadow.appendChild(content);\n  }\n  /* Private method called by append() \n   */\n\n\n  _appendBasic(elt, content) {\n    this.hideContent(elt);\n    elt.appendChild(content);\n  }\n  /* Wrapper for deprecated method now known as define()\n   */\n\n\n  registerAll(names) {\n    this.define(names);\n  }\n  /* Registers the list of elements provided with the browser.\n      Called by makeHTML5(), but can be called independently if, for example,\n     you've created Custom Elements via an XSLT transformation instead.\n   */\n\n\n  define(names) {\n    for (let name of names) {\n      try {\n        let fn = this.getHandler(name);\n        window.customElements.define(this._tagName(name), class extends HTMLElement {\n          constructor() {\n            super();\n\n            if (!this.matches(\":defined\")) {\n              // \"Upgraded\" undefined elements can have attributes & children; new elements can't\n              if (fn) {\n                fn.call(this);\n              } // We don't want to double-process elements, so add a flag\n\n\n              this.setAttribute(\"data-processed\", \"\");\n            }\n          } // Process new elements when they are connected to the browser DOM\n\n\n          connectedCallback() {\n            if (!this.hasAttribute(\"data-processed\")) {\n              if (fn) {\n                fn.call(this);\n              }\n\n              this.setAttribute(\"data-processed\", \"\");\n            }\n          }\n\n        });\n      } catch (error) {\n        console.log(this._tagName(name) + \" couldn't be registered or is already registered.\");\n        console.log(error);\n      }\n    }\n  }\n  /* Provides fallback functionality for browsers where Custom Elements\n     are not supported.\n      Like define(), this is called by makeHTML5(), but can be called\n     independently.\n  */\n\n\n  fallback(names) {\n    for (let name of names) {\n      let fn = this.getFallback(name);\n\n      if (fn) {\n        for (let elt of Array.from((this.dom && !this.done ? this.dom : document).getElementsByTagName(this._tagName(name)))) {\n          if (!elt.hasAttribute(\"data-processed\")) {\n            this.append(fn, elt);\n          }\n        }\n      }\n    }\n  }\n  /**********************\n   * Utility functions  *\n   **********************/\n\n  /* Takes a relative URL and rewrites it based on the base URL of the\n     HTML document */\n\n\n  rw(url) {\n    if (!url.match(/^(?:http|mailto|file|\\/|#).*$/)) {\n      return this.base + url;\n    } else {\n      return url;\n    }\n  }\n  /* Given a space-separated list of URLs (e.g. in a ref with multiple\n     targets), returns just the first one.\n   */\n\n\n  first(urls) {\n    return urls.replace(/ .*$/, \"\");\n  }\n\n  normalizeURI(urls) {\n    return this.rw(this.first(urls));\n  }\n  /* Takes a string and a number and returns the original string\n     printed that number of times.\n  */\n\n\n  repeat(str, times) {\n    let result = \"\";\n\n    for (let i = 0; i < times; i++) {\n      result += str;\n    }\n\n    return result;\n  }\n  /* Performs a deep copy operation of the input node while stripping\n   * out child elements introduced by CETEIcean.\n   */\n\n\n  copyAndReset(node) {\n    let _clone = n => {\n      let result = n.nodeType === Node.ELEMENT_NODE ? document.createElement(n.nodeName) : n.cloneNode(true);\n\n      if (n.attributes) {\n        for (let att of Array.from(n.attributes)) {\n          if (att.name !== \"data-processed\") {\n            result.setAttribute(att.name, att.value);\n          }\n        }\n      }\n\n      for (let nd of Array.from(n.childNodes)) {\n        if (nd.nodeType == Node.ELEMENT_NODE) {\n          if (!n.hasAttribute(\"data-empty\")) {\n            if (nd.hasAttribute(\"data-original\")) {\n              for (let childNode of Array.from(nd.childNodes)) {\n                let child = result.appendChild(_clone(childNode));\n\n                if (child.nodeType === Node.ELEMENT_NODE && child.hasAttribute(\"data-origid\")) {\n                  child.setAttribute(\"id\", child.getAttribute(\"data-origid\"));\n                  child.removeAttribute(\"data-origid\");\n                }\n              }\n\n              return result;\n            } else {\n              result.appendChild(_clone(nd));\n            }\n          }\n        } else {\n          result.appendChild(nd.cloneNode());\n        }\n      }\n\n      return result;\n    };\n\n    return _clone(node);\n  }\n  /* Takes an element and serializes it to an XML string or, if the stripElt\n     parameter is set, serializes the element's content.\n   */\n\n\n  serialize(el, stripElt) {\n    let str = \"\";\n\n    if (!stripElt) {\n      str += \"&lt;\" + el.getAttribute(\"data-origname\");\n\n      for (let attr of Array.from(el.attributes)) {\n        if (!attr.name.startsWith(\"data-\") && ![\"id\", \"lang\", \"class\"].includes(attr.name)) {\n          str += \" \" + attr.name + \"=\\\"\" + attr.value + \"\\\"\";\n        }\n\n        if (attr.name == \"data-xmlns\") {\n          str += \" xmlns=\\\"\" + attr.value + \"\\\"\";\n        }\n      }\n\n      if (el.childNodes.length > 0) {\n        str += \">\";\n      } else {\n        str += \"/>\";\n      }\n    } //TODO: Be smarter about skipping generated content with hidden original\n\n\n    for (let node of Array.from(el.childNodes)) {\n      switch (node.nodeType) {\n        case Node.ELEMENT_NODE:\n          str += this.serialize(node);\n          break;\n\n        case Node.PROCESSING_INSTRUCTION_NODE:\n          str += \"&lt;?\" + node.nodeValue + \"?>\";\n          break;\n\n        case Node.COMMENT_NODE:\n          str += \"&lt;!--\" + node.nodeValue + \"-->\";\n          break;\n\n        default:\n          str += node.nodeValue.replace(/</g, \"&lt;\");\n      }\n    }\n\n    if (!stripElt && el.childNodes.length > 0) {\n      str += \"&lt;/\" + el.getAttribute(\"data-origname\") + \">\";\n    }\n\n    return str;\n  }\n  /* Wraps the content of the element parameter in a <span data-original>\n   * with display set to \"none\".\n   */\n\n\n  hideContent(elt, rewriteIds = true) {\n    if (elt.childNodes.length > 0) {\n      let hidden = document.createElement(\"span\");\n      elt.appendChild(hidden);\n      hidden.setAttribute(\"hidden\", \"\");\n      hidden.setAttribute(\"data-original\", \"\");\n\n      for (let node of Array.from(elt.childNodes)) {\n        if (node !== hidden) {\n          hidden.appendChild(elt.removeChild(node));\n        }\n      }\n\n      if (rewriteIds) {\n        for (let e of Array.from(hidden.querySelectorAll(\"*\"))) {\n          if (e.hasAttribute(\"id\")) {\n            e.setAttribute(\"data-origid\", e.getAttribute(\"id\"));\n            e.removeAttribute(\"id\");\n          }\n        }\n      }\n    }\n  }\n\n  unEscapeEntities(str) {\n    return str.replace(/&gt;/, \">\").replace(/&quot;/, \"\\\"\").replace(/&apos;/, \"'\").replace(/&amp;/, \"&\");\n  }\n\n  static savePosition() {\n    window.localStorage.setItem(\"scroll\", window.scrollY);\n  }\n\n  static restorePosition() {\n    if (!window.location.hash) {\n      if (window.localStorage.getItem(\"scroll\")) {\n        setTimeout(function () {\n          window.scrollTo(0, localStorage.getItem(\"scroll\"));\n        }, 100);\n      }\n    } else {\n      setTimeout(function () {\n        document.querySelector(window.location.hash).scrollIntoView();\n      }, 100);\n    }\n  } // public method\n\n\n  fromODD() {// Place holder for ODD-driven setup.\n    // For example:\n    // Create table of elements from ODD\n    //    * default HTML behaviour mapping on/off (eg tei:div to html:div)\n    //    ** phrase level elements behave like span (can I tell this from ODD classes?)\n    //    * optional custom behaviour mapping\n  }\n\n} // Make main class available to pre-ES6 browser environments\n\n\ntry {\n  if (window) {\n    window.CETEI = CETEI;\n    window.addEventListener(\"beforeunload\", CETEI.savePosition);\n    var ceteiceanLoad = new Event(\"ceteiceanload\");\n    window.addEventListener(\"ceteiceanload\", CETEI.restorePosition);\n  }\n} catch (e) {// window not defined;\n}\n\nexport default CETEI;","map":null,"metadata":{},"sourceType":"module"}